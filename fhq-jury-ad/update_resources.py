#!/usr/bin/python
# -*- coding: utf-8 -*-
import os
import re

basedir = "../jury.d/html/"
sourcedir = "./src/resources/files/"

result = [os.path.join(dp, f) for dp, dn, filenames in os.walk(basedir) for f in filenames]

files = []

for filename in result:
    statinfo = os.stat(filename)
    size = statinfo.st_size

    filename_ = filename[len(basedir):]
    newfilename = re.sub(r"[^a-zA-Z0-9_]", "_", filename_)

    if newfilename in files:
        print("WARNING: " + newfilename + " - already defined")
        continue

    print("Prepare " + filename + " to " + sourcedir + newfilename + ".*")
    _header = open(sourcedir + newfilename + ".h", "w")
    _source = open(sourcedir + newfilename + ".cpp", "w")
    
    _classname = "RES_" + newfilename

    _header.write("// automaticly generated by update_resources.py\n\n")
    _header.write("\n")
    _header.write("#include <resources_manager.h>\n")
    _header.write("\n")
    _header.write("class " + _classname + " : public ResourceFile { \n")
    _header.write("    public:\n")
    _header.write("        virtual const std::string &filename();\n")
    _header.write("        virtual const int bufferSize();\n")
    _header.write("        virtual const char *buffer();\n")
    _header.write("};\n")
    _header.write("\n")

    _source.write("// automaticly generated by update_resources.py\n")
    _source.write("\n")
    _source.write("#include <" + newfilename + ".h>\n")
    _source.write("\n")
    _source.write("REGISTRY_RESOURCE_FILE(" + _classname + ")\n")
    _source.write("\n")
    _source.write("const std::string &" + _classname + "::filename() {\n")
    _source.write("    static const std::string s = \"" + filename_ + "\";\n")
    _source.write("    return s;\n")
    _source.write("}\n")
    _source.write("\n")
    _source.write("const int " + _classname + "::bufferSize() {\n")
    _source.write("    return " + str(size) + ";\n")
    _source.write("}\n")
    _source.write("\n")
    _source.write("const char *" + _classname + "::buffer() {\n")
    _source.write("    static const unsigned char b[" + str(size) + "] = {")
    i = 0
    with open(filename, "rb") as f:
        byte = f.read(1)
        while byte != b'':
            # Do stuff with byte.
            if i != 0:
                _source.write(", ")
            if i % 16 == 0:
                _source.write("\n        ")
            _source.write("0x" + byte.encode('hex'))
            i = i + 1
            byte = f.read(1)
        _source.write("\n    };\n")
    if i != size:
        print("Expected " + str(size) + " got " + str(i))
        
    _source.write("    return (const char*)b;\n")
    _source.write("} //::buffer() \n")
    _source.write("\n")
    _header.close()
    _source.close()
